---
title: "Analysis Procedure"
author: "Simone D'Ambrogio"
subtitle: "Short Version"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: true
    toc: true
    toc_depth: 2
    toc_float: true
    theme: united
    highlight: tango
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE, fig.align='left')
library(knitr)
## Global options
options(max.print="75")
opts_chunk$set(
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE
               )
opts_knit$set(width=75)
```

<style type="text/css">
  body {
    text-align: justify;
    font-size: 16px;
  }
  img[src$="centerme"] {
    display:block;
    margin: 0 auto;
  }
  
  p.comment {
    background-color: #DBDBDB;
    padding: 10px;
    border: 1px solid black;
    border-radius: 5px;
}

</style>

<br><br>

```{r mytheme}
mytheme <- function (palette = "black_and_white", base_size = 14, base_family = "sans", 
                     base_fontface = "plain", base_line_size = base_size/20, base_rect_size = base_size/14, 
                     axis_text_angle = 0, border = FALSE) {
  
  is_bool <- function(x) {
    is_logical(x, n = 1) && !is.na(x)
  } 
  angle <- axis_text_angle[1]
   if (!angle %in% c(0, 45, 90, 270)) 
     stop(sprintf("'axis_text_angle' must be one of [%s]", 
                  paste(c(0, 45, 90, 270), collapse = ", ")), ".\nFor other angles, use the guide_axis() function in ggplot2 instead", 
          call. = FALSE)
   if (!palette %in% names(ggprism::ggprism_data$themes)) {
     stop("The palette ", paste(palette), " does not exist.\n         See names(ggprism_data$themes) for valid palette names")
   }
   colours <- tibble::deframe(ggprism::ggprism_data$themes[[palette]])
   if (!is_bool(border)) {
     stop("border must be either: TRUE or FALSE")
   }
   else {
     if (border) {
       panel.border <- element_rect(fill = NA)
       axis.line <- element_blank()
     }
     else if (!border) {
       panel.border <- element_blank()
       axis.line <- element_line()
     }
   }
   t <- theme(line = element_line(colour = colours["axisColor"], 
                                  size = base_line_size, linetype = 1, lineend = "square"), 
              rect = element_rect(fill = "white", colour = colours["axisColor"], 
                                  size = base_rect_size, linetype = 1), text = element_text(family = base_family, 
                                                                                            face = base_fontface, colour = colours["graphTitleColor"], 
                                                                                            size = base_size, lineheight = 0.9, hjust = 0.5, 
                                                                                            vjust = 0.5, angle = 0, margin = margin(), debug = FALSE), 
              prism.ticks.length = unit(base_size/50, "pt"), axis.line = axis.line, 
              axis.line.x = NULL, axis.line.y = NULL, axis.text = element_text(size = rel(0.95), 
                                                                               colour = colours["axisLabelColor"]), axis.text.x = element_text(margin = margin(t = 0.8 * 
                                                                                                                                                                 base_size/4), angle = axis_text_angle, hjust = ifelse(axis_text_angle %in% 
                                                                                                                                                                                                                         c(45, 90, 270), 1, 0.5), vjust = ifelse(axis_text_angle %in% 
                                                                                                                                                                                                                                                                   c(0, 90, 270), 0.5, 1)), axis.text.x.top = element_text(margin = margin(b = 0.8 * 
                                                                                                                                                                                                                                                                                                                                             base_size/4), vjust = 0), axis.text.y = element_text(margin = margin(r = 0.5 * 
                                                                                                                                                                                                                                                                                                                                                                                                                    base_size/4), hjust = 1), axis.text.y.right = element_text(margin = margin(l = 0.5 * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 base_size/4), hjust = 0), axis.ticks = element_line(), 
              axis.ticks.length = unit(3, "points"), axis.ticks.length.x = NULL, 
              axis.ticks.length.x.top = NULL, axis.ticks.length.x.bottom = NULL, 
              axis.ticks.length.y = NULL, axis.ticks.length.y.left = NULL, 
              axis.ticks.length.y.right = NULL, axis.title = element_text(colour = colours["axisTitleColor"]), 
              axis.title.x = element_text(margin = margin(t = base_size * 
                                                            0.6), vjust = 1), axis.title.x.top = element_text(margin = margin(b = base_size * 
                                                                                                                                0.6), vjust = 0), axis.title.y = element_text(angle = 90, 
                                                                                                                                                                              margin = margin(r = base_size * 0.6), vjust = 1), 
              axis.title.y.right = element_text(angle = -90, margin = margin(l = base_size * 
                                                                               0.6), vjust = 0), legend.background = element_blank(), 
              legend.spacing = unit(base_size, "pt"), legend.spacing.x = NULL, 
              legend.spacing.y = NULL, legend.margin = margin(base_size/2, 
                                                              base_size/2, base_size/2, base_size/2), legend.key = element_blank(), 
              legend.key.size = unit(1.2, "lines"), legend.key.height = NULL, 
              legend.key.width = unit(base_size * 1.8, "pt"), legend.text = element_text(size = rel(0.8), 
                                                                                         face = "plain"), legend.text.align = NULL, legend.title = element_blank(), 
              legend.title.align = NULL, legend.position = "right", 
              legend.direction = NULL, legend.justification = "center", 
              legend.box = NULL, legend.box.margin = margin(0, 0, 0, 
                                                            0, "cm"), legend.box.background = element_blank(), 
              legend.box.spacing = unit(base_size, "pt"), panel.background = element_rect(fill = ifelse(palette == 
                                                                                                          "office", colours["plottingAreaColor"], NA), colour = NA), 
              panel.border = panel.border, panel.grid = element_blank(), 
              panel.grid.minor = element_blank(), panel.spacing = unit(base_size/2, 
                                                                       "pt"), panel.spacing.x = NULL, panel.spacing.y = NULL, 
              panel.ontop = FALSE, strip.background = element_blank(), 
              strip.text = element_text(colour = colours["axisTitleColor"], 
                                        size = rel(0.8), margin = margin(base_size/2.5, base_size/2.5, 
                                                                         base_size/2.5, base_size/2.5)), strip.text.x = element_text(margin = margin(b = base_size/3)), 
              strip.text.y = element_text(angle = -90, margin = margin(l = base_size/3)), 
              strip.text.y.left = element_text(angle = 90), strip.placement = "inside", 
              strip.placement.x = NULL, strip.placement.y = NULL, strip.switch.pad.grid = unit(base_size/4, 
                                                                                               "pt"), strip.switch.pad.wrap = unit(base_size/4, 
                                                                                                                                   "pt"), plot.background = element_rect(fill = colours["pageBackgroundColor"], 
                                                                                                                                                                         colour = NA), plot.title = element_text(size = rel(1.2), 
                                                                                                                                                                                                                 hjust = 0.5, vjust = 1, margin = margin(b = base_size)), 
              plot.title.position = "panel", plot.subtitle = element_text(hjust = 0.5, 
                                                                          vjust = 1, margin = margin(b = base_size/2)), plot.caption = element_text(size = rel(0.8), 
                                                                                                                                                    hjust = 1, vjust = 1, margin = margin(t = base_size/2)), 
              plot.caption.position = "panel", plot.tag = element_text(size = rel(1.2), 
                                                                       hjust = 0.5, vjust = 0.5), plot.tag.position = "topleft", 
              plot.margin = margin(base_size/2, base_size/2, base_size/2, 
                                   base_size/2), complete = TRUE)
   ggprism::ggprism_data$themes[["all_null"]] %+replace% t
 }
```


```{r load-data&library, results='hide'}

# Load libraries
library(dplyr); library(purrr); library(stringr)
library(ggplot2); library(ggpubr); library(jcolors)
library(cowplot); library(ggprism); library(tidybayes)
library(reshape2); library(parallel); library(rstan)


effect_size = c("Paper Effect Size",
                "Paper Effect Size/2",
                "Paper Effect Size/4",
                "Paper Effect Size/8")
# Functions
psoftmax <- function(b) exp(c(0, b)) / sum(exp( c(0, b) ))

words_replace <- function(variable, words_to_replace, replace_with = "") {

    library(dplyr)
    if (!require(dplyr)) {
        install.packages("dplyr")
        library(dplyr)
    }

    # variable <- enquo(variable) var <- select(data, !!variable) %>% .[,]

    if (!is.character(variable))
        variable <- as.character(variable)

    for (word_i in 1:length(words_to_replace)) {
        word_to_rm_index <- which(str_detect(variable, fixed(words_to_replace[word_i])))

        if (any(word_to_rm_index)) {
            words_to_replace_i <- words_to_replace[word_i]
            new_words <- sapply(seq_along(word_to_rm_index), function(i) {
                variable[word_to_rm_index][i] <- gsub(words_to_replace_i, replace_with,
                  variable[word_to_rm_index][i], fixed = TRUE)
            })
            variable[word_to_rm_index] <- new_words
        } else {
            warning(paste0("Sting '", words_to_replace, "' not found"))
        }
    }

    return(variable)
}

# Load data
data_short <- readRDS('../Data/data_short.rds')$data %>% 
  mutate(subject=1:n()) %>% 
  rename(age=`Age.`, A3=`A3.`)

questions  <- readRDS('../Data/data_short.rds')$question

# ----- Mental Accounting ----- #
# Remove final questionnaires
data_short_MA <- data_short[, -(48:75)]
# Remove response time
idx_time      <- str_detect( names(data_short_MA),  'time_')
data_short_MA <- data_short_MA[, !idx_time] 

data_short_MA <- data_short_MA %>% 
  rename_with(~gsub('.', '', .x, fixed = TRUE)) %>% 
  rename_with(toupper, .cols = -contains('subject'))

n_sbj <- nrow( data_short_MA )
```

<br><br>

## Mr. A vs Mr. B2

<br>

### {.tabset}

#### Data

```{r plot-empirical-data-S1, message=F, warning=F, fig.width=6, fig.height=5, fig.align='center'}

# ---------- Mr. A vs Mr. B2 Scenario ---------- #

# Coding legend:
# response: 0 (Happier/More upset);  
#           1 (Less Happy/Less upset)
#           2 (No difference)

# Create dataframe scenario 1
data_s1 <- data_short %>% 
  select(subject, contains('A', ignore.case = FALSE)) %>% 
  # Recode response
  mutate(`gain-gain VS gain` = case_when(A1=='A'~0, A1=='B'~1, T~2),
         `loss-loss VS loss` = case_when(A2=='A'~0, A2=='B'~1, T~2),
         `gain-loss VS gain` = case_when(A3=='A'~0, A3=='B'~1, T~2),
         `loss-gain VS loss` = case_when(A4=='A'~0, A4=='B'~1, T~2)
         ) %>% 
  select(-contains('A', ignore.case=FALSE)) %>% 
  melt(id.var='subject',
       variable.name='scenario',
       value.name='response')

data_s1 %>% 
  ggplot(aes(response)) +
  geom_bar(aes(y = (..count..)/sum(..count..)), fill=jcolors::jcolors(palette = "pal8")[2]) + 
  mytheme() + theme(legend.position = 'none', 
                    axis.title.y=element_blank(),
                    axis.text.y=element_blank()) +
  scale_fill_brewer(palette = 'Set1') +
  scale_y_continuous(labels=scales::percent, guide = "prism_offset") +
  scale_x_continuous(guide = "prism_offset", breaks = 0:2, labels = c('A', 'B', 'Same')) +
  labs(y=NULL, x=NULL) +
  facet_wrap(~scenario)
```

#### Questions

<br>
<p class="comment">
Mr. A was given two tickets to the Regional lottery. He won &#36;50 in one lottery and &#36;25 in the other.  <br><br>
Mr. B was given a ticket to a single, larger Regional lottery. He won &#36;75.  <br><br>
Who is happier? 
</p>

<div class="alert alert-info">
  A/B/No difference
</div>

<br><br>
<p class="comment">
Mr. A received a letter from the IRS saying that he made a minor arithmetical mistake on his tax return and owed &#36;100. He received a similar letter the same day from his state income tax authority saying he owed &#36;50. There were no other repercussions from either mistake. <br><br>
Mr. B received a letter from the IRS saying he made a minor arithmetical mistake on his tax return and owed &#36;150. There were no other repercussions from this mistake. <br><br>
Who more upset? 
</p>

<div class="alert alert-info">
  A/B/No difference
</div>

<br><br>
<p class="comment">
Mr. A bought his first National lottery ticket and won &#36;100. Also, in a freak accident, he damaged the rug in his apartment and had to pay the landlord &#36;80. <br><br>
Mr. B bought his first National lottery ticket and won &#36;20.<br><br>
Who is happier?
</p>

<div class="alert alert-info">
  A/B/No difference
</div>

<br><br>
<p class="comment">
Mr. A’s car was damaged in a parking lot. He had to spend &#36;200 to repair the damage. The same day the car was damaged, he won &#36;25 in the office holiday raffle. <br><br>
Mr. B’s car was damaged in a parking lot. He had to spend &#36;175 to repair the damage.<br><br>
Who is more upset? 
</p>

<div class="alert alert-info">
  A/B/No difference
</div>

#### Stan Code

```{stan stan-code-S1, output.var='mixture_scenario_1', code=readLines('mental_accounting.stan'), cache=TRUE}
    
```


```{r print-stan-code-S1, eval = TRUE, echo = FALSE}
cat(get_stancode(mixture_scenario_1))
```

#### Fit

```{r fit-stan-model-S1, message=F, warning=F, fig.width=6, fig.height=5, fig.align='center'}
# ---- Fit Model ---- #
library(rstan)
library(tidybayes)
options(mc.cores = 4)
rstan_options(auto_write = TRUE)

# ------------- ~ scenario ------------- #
# Create Stan Data
X <- model.matrix(~ 0 + scenario, data_s1)

#Stan Data
stan_data <- list(
    N        = nrow(data_s1),
    Y        = data_s1$response,
    X_ds     = X,
    X_cA     = X,
    K_ds     = ncol(X),
    K_cA     = ncol(X),
    
    N_sbj    = n_sbj,
    J_sbj    = data_s1$subject,
    
    prior_only = 0
  )

# Fit the model
fit_S1 <- rstan::sampling(mixture_scenario_1, 
                          iter = 2000, 
                          cores = 4, 
                          data = stan_data, 
                          save_warmup = FALSE)
```

**Plot Model Posteriors**

```{r plot-posteriors-stan-model-S1, message=F, warning=F, fig.width=9, fig.height=5, fig.align='center'}
draws <- extract(fit_S1) 
colnames(draws$b_ds) <- words_replace(colnames(X), 'scenario')
colnames(draws$b_cA) <- words_replace(colnames(X), 'scenario')

rbind(draws$b_ds %>% melt() %>% mutate(type='P[Different vs Same]'),
      draws$b_cA %>% melt() %>% mutate(type='P[A vs B | Different]')) %>% 
  mutate(Var2 = factor(Var2, levels = rev(unique(.$Var2))),
         type = factor(type, levels = rev(unique(.$type)))) %>% 
  ggplot(aes(x = value, y = Var2)) + 
  stat_halfeye(fill = jcolors::jcolors(palette = "pal8")[6],
               color = jcolors::jcolors(palette = "pal8")[12]) + 
  mytheme() + 
  geom_vline(xintercept = 0, linetype = 2) + 
  labs(y = NULL, x = "Posterior Probability") +
  facet_grid(~type)
```


#### Power Analysis

```{r power-analysis-S1, message=F, warning=F, fig.width=6, results='hide', eval=TRUE}
# ---- Power Calculation ---- #
nModels <- 4
nChains <- 2
nClusters <- nModels*nChains

n_sim <- 100
n_sbj_range <- c(10, 50, 100, 150, 200, 250, 300) 

# Calculate the probability of responding 'different'
logit = function(p) log(p/(1-p))

# Effect found in the paper Thaler 1985
n_sbj    = 87
scenario = 1:4
A        = c(56, 66, 22, 19)
B        = c(16, 14, 61, 63)
ds       = (A+B)/n_sbj # Probability to choose Different
cA       = A/(A+B)

effect_ds = logit(ds)
effect_cA = logit(cA)

sim_y <- function(sbj, mu_ds, mu_cA){
  
  std      = 0.5
  n_sbj    = 87
  scenario = 1:4
  A        = c(56, 66, 22, 19)
  B        = c(16, 14, 61, 63)
  ds       = (A+B)/n_sbj # Probability to choose Different
  cA       = A/(A+B)

  # Random Effect
  re_ds <- rnorm(1, 0, std)
  re_cA <- rnorm(1, 0, std)
  # Probability of 'Different' and Conditional Probability of 'A'
  p_ds <- plogis(mu_ds+re_ds)
  p_cA <- plogis(mu_cA+re_cA)
  
  response <- sapply( scenario, function(i){
    y_ds <- rbinom( 1, 1, p_ds[i])
    if( y_ds==1 ){
      response = rbinom(1, 1, (1-cA[i]) )
    } else {
      response = 2
    }
    response
  })
  
  return( data.frame(subject=sbj, response, scenario=paste0('s', scenario)) )
}

samplingfunction <- function(x){
  
  
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), 
                             sim_y, mu_ds=effect_ds, 
                             mu_cA=effect_cA)
  
  ## Create Stan Data
  X <- model.matrix(~ 0 + scenario, data_sim)
  
  #Stan Data
  stan_data <- list(
    N        = nrow(data_sim),
    Y        = data_sim$response,
    X_ds     = X,
    X_cA     = X,
    K_ds     = ncol(X),
    K_cA     = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )
  
  # Fit the model
  fit <- rstan::sampling(mixture_scenario_1, 
                         iter   = 2000, 
                         cores  = 2, 
                         chains = 2,
                         pars   = c('b_ds', 'b_cA'),
                         data   = stan_data, 
                         refresh = 0,
                         save_warmup = FALSE)
  efit <- rstan::extract(fit)
  
  
  rbind(
    data.frame(
      estimate = apply(efit$b_ds, 2, mean),
      lwr      = apply(efit$b_ds, 2, quantile, probs=0.025),
      upr      = apply(efit$b_ds, 2, quantile, probs=0.975),
      type     = 'p_different',
      scenario = paste0('s', 1:4),
      N        = n
    ),
  
    data.frame(
      estimate = apply(efit$b_cA, 2, mean),
      lwr      = apply(efit$b_cA, 2, quantile, probs=0.025),
      upr      = apply(efit$b_cA, 2, quantile, probs=0.975),
      type     = 'p_A|different',
      scenario = paste0('s', 1:4),
      N        = n
    )
  )
  
}

samplingfunction2 <- function(x){
  
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), 
                             sim_y, mu_ds=effect_ds/2, 
                             mu_cA=effect_cA/2)
  
  ## Create Stan Data
  X <- model.matrix(~ 0 + scenario, data_sim)
  
  #Stan Data
  stan_data <- list(
    N        = nrow(data_sim),
    Y        = data_sim$response,
    X_ds     = X,
    X_cA     = X,
    K_ds     = ncol(X),
    K_cA     = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )
  
  # Fit the model
  fit <- rstan::sampling(mixture_scenario_1, 
                         iter   = 2000, 
                         cores  = 2, 
                         chains = 2,
                         pars   = c('b_ds', 'b_cA'),
                         data   = stan_data, 
                         refresh = 0,
                         save_warmup = FALSE)
  efit <- rstan::extract(fit)
  
  
  rbind(
    data.frame(
      estimate = apply(efit$b_ds, 2, mean),
      lwr      = apply(efit$b_ds, 2, quantile, probs=0.025),
      upr      = apply(efit$b_ds, 2, quantile, probs=0.975),
      type     = 'p_different',
      scenario = paste0('s', 1:4),
      N        = n
    ),
  
    data.frame(
      estimate = apply(efit$b_cA, 2, mean),
      lwr      = apply(efit$b_cA, 2, quantile, probs=0.025),
      upr      = apply(efit$b_cA, 2, quantile, probs=0.975),
      type     = 'p_A|different',
      scenario = paste0('s', 1:4),
      N        = n
    )
  )
  
}

samplingfunction3 <- function(x){
  
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), 
                             sim_y, mu_ds=effect_ds/4, 
                             mu_cA=effect_cA/4)
  
  ## Create Stan Data
  X <- model.matrix(~ 0 + scenario, data_sim)
  
  #Stan Data
  stan_data <- list(
    N        = nrow(data_sim),
    Y        = data_sim$response,
    X_ds     = X,
    X_cA     = X,
    K_ds     = ncol(X),
    K_cA     = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )
  
  # Fit the model
  fit <- rstan::sampling(mixture_scenario_1, 
                         iter   = 2000, 
                         cores  = 2, 
                         chains = 2,
                         pars   = c('b_ds', 'b_cA'),
                         data   = stan_data, 
                         refresh = 0,
                         save_warmup = FALSE)
  efit <- rstan::extract(fit)
  
  
  rbind(
    data.frame(
      estimate = apply(efit$b_ds, 2, mean),
      lwr      = apply(efit$b_ds, 2, quantile, probs=0.025),
      upr      = apply(efit$b_ds, 2, quantile, probs=0.975),
      type     = 'p_different',
      scenario = paste0('s', 1:4),
      N        = n
    ),
  
    data.frame(
      estimate = apply(efit$b_cA, 2, mean),
      lwr      = apply(efit$b_cA, 2, quantile, probs=0.025),
      upr      = apply(efit$b_cA, 2, quantile, probs=0.975),
      type     = 'p_A|different',
      scenario = paste0('s', 1:4),
      N        = n
    )
  )
  
}

samplingfunction4 <- function(x){
  
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), 
                             sim_y, mu_ds=effect_ds/8, 
                             mu_cA=effect_cA/8)
  
  ## Create Stan Data
  X <- model.matrix(~ 0 + scenario, data_sim)
  
  #Stan Data
  stan_data <- list(
    N        = nrow(data_sim),
    Y        = data_sim$response,
    X_ds     = X,
    X_cA     = X,
    K_ds     = ncol(X),
    K_cA     = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )
  
  # Fit the model
  fit <- rstan::sampling(mixture_scenario_1, 
                         iter   = 2000, 
                         cores  = 2, 
                         chains = 2,
                         pars   = c('b_ds', 'b_cA'),
                         data   = stan_data, 
                         refresh = 0,
                         save_warmup = FALSE)
  efit <- rstan::extract(fit)
  
  
  rbind(
    data.frame(
      estimate = apply(efit$b_ds, 2, mean),
      lwr      = apply(efit$b_ds, 2, quantile, probs=0.025),
      upr      = apply(efit$b_ds, 2, quantile, probs=0.975),
      type     = 'p_different',
      scenario = paste0('s', 1:4),
      N        = n
    ),
  
    data.frame(
      estimate = apply(efit$b_cA, 2, mean),
      lwr      = apply(efit$b_cA, 2, quantile, probs=0.025),
      upr      = apply(efit$b_cA, 2, quantile, probs=0.975),
      type     = 'p_A|different',
      scenario = paste0('s', 1:4),
      N        = n
    )
  )
  
}
```

```{r power-analysis-computation-effsize1-S1, message=F, warning=F, results='hide', eval=TRUE}
power <- data.frame()
for(n in n_sbj_range) {
  message('\n\nN Subjects: ', n, '\n')
  
  message('Setting up Clusters...')
  cl <- parallel::makeCluster(nClusters, outfile = "")
  parallel::clusterExport(cl, c('mixture_scenario_1', 'n_sbj_range',
                                'sim_y', 'effect_ds', 'effect_cA', 
                                'n'))
  
  out <- map_dfr(seq_len( round(n_sim/nModels) ), function(i){
    message( '\r', 'Simulation: ', i*nModels, '/', n_sim, appendLF = FALSE)
    parallel::parLapply(cl, 1:nModels, samplingfunction)
  })
  power <- rbind(power, out)
  
  message('Shutting down Clusters...')
  parallel::stopCluster(cl)
}
```

```{r power-analysis-computation-effsize2-S1, message=F, warning=F, results='hide', eval=TRUE}
power2 <- data.frame()
for(n in n_sbj_range){
  message('\n\nN Subjects: ', n, '\n')
  
  message('Setting up Clusters...')
  cl <- parallel::makeCluster(nClusters, outfile = "")
  parallel::clusterExport(cl, c('mixture_scenario_1', 'n_sbj_range',
                                'sim_y', 'effect_ds', 'effect_cA', 
                                'n'))
  
  out <- map_dfr(seq_len( round(n_sim/nModels) ), function(i){
    message( '\r', 'Simulation: ', i*nModels, '/', n_sim, appendLF = FALSE)
    parallel::parLapply(cl, 1:nModels, samplingfunction2)
  })
  power2 <- rbind(power2, out)
  
  message('Shutting down Clusters...')
  parallel::stopCluster(cl)
}
```

```{r power-analysis-computation-effsize3-S1, message=F, warning=F, results='hide', eval=TRUE}
power3 <- data.frame()

for(n in n_sbj_range){
  message('\n\nN Subjects: ', n, '\n')
  
  message('Setting up Clusters...')
  cl <- parallel::makeCluster(nClusters, outfile = "")
  parallel::clusterExport(cl, c('mixture_scenario_1', 'n_sbj_range',
                                'sim_y', 'effect_ds', 'effect_cA', 
                                'n'))
  
  out <- map_dfr(seq_len( round(n_sim/nModels) ), function(i){
    message( '\r', 'Simulation: ', i*nModels, '/', n_sim, appendLF = FALSE)
    parallel::parLapply(cl, 1:nModels, samplingfunction3)
  })
  power3 <- rbind(power3, out)
  
  message('Shutting down Clusters...')
  parallel::stopCluster(cl)
}
```

```{r power-analysis-computation-effsize4-S1, message=F, warning=F, results='hide', eval=TRUE}
power4 <- data.frame()

for(n in n_sbj_range){
  message('\n\nN Subjects: ', n, '\n')
  
  message('Setting up Clusters...')
  cl <- parallel::makeCluster(nClusters, outfile = "")
  parallel::clusterExport(cl, c('mixture_scenario_1', 'n_sbj_range',
                                'sim_y', 'effect_ds', 'effect_cA', 
                                'n'))
  
  out <- map_dfr(seq_len( round(n_sim/nModels) ), function(i){
    message( '\r', 'Simulation: ', i*nModels, '/', n_sim, appendLF = FALSE)
    parallel::parLapply(cl, 1:nModels, samplingfunction4)
  })
  power4 <- rbind(power4, out)
  
  message('Shutting down Clusters...')
  parallel::stopCluster(cl)
  
}
```

```{r plot-power-S1, eval=TRUE, fig.align='center', fig.height=18, fig.width=7, message=FALSE, warning=FALSE}

pw1 <- power %>% 
    mutate(
      is_significant = case_when(
        type=='p_different' & lwr<0 ~ FALSE,
        type=='p_different' & lwr>0 ~ TRUE,
        lwr<0 & scenario%in%c('s1', 's2') ~ FALSE,
        upr>0 & scenario%in%c('s3', 's4') ~ FALSE,
        T ~ TRUE ),
      type=ifelse(type=='p_different', 'P(Different)', 'P(A|Different)'),
      scenario = case_when(
        scenario=='s1'~ 'gain-gain VS gain',
        scenario=='s2'~ 'loss-loss VS loss',
        scenario=='s3'~ 'gain-loss VS gain',
        scenario=='s4'~ 'loss-gain VS loss'
      )) %>% 
    group_by(N, type, scenario) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>% 
    ggplot(aes(N, power, color=type)) +
    geom_line(size=1) +
    geom_point(size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    mytheme() + theme(legend.position = 'top') +
    facet_wrap(~scenario) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β', title = 'Original Paper Effect Size') +
    scale_color_jcolors(palette = "pal6")

pw2 <- power2 %>% 
    mutate(
      is_significant = case_when(
        type=='p_different' & lwr<0 ~ FALSE,
        type=='p_different' & lwr>0 ~ TRUE,
        lwr<0 & scenario%in%c('s1', 's2') ~ FALSE,
        upr>0 & scenario%in%c('s3', 's4') ~ FALSE,
        T ~ TRUE ),
      type=ifelse(type=='p_different', 'P(Different)', 'P(A|Different)'),
      scenario = case_when(
        scenario=='s1'~ 'gain-gain VS gain',
        scenario=='s2'~ 'loss-loss VS loss',
        scenario=='s3'~ 'gain-loss VS gain',
        scenario=='s4'~ 'loss-gain VS loss'
      )) %>% 
    group_by(N, type, scenario) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>% 
    ggplot(aes(N, power, color=type)) +
    geom_line(size=1) +
    geom_point(size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    mytheme() + theme(legend.position = 'none') +
    facet_wrap(~scenario) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β', title = 'Original Paper Effect Size/2') +
    scale_color_jcolors(palette = "pal6")

pw3 <- power3 %>% 
    mutate(
      is_significant = case_when(
        type=='p_different' & lwr<0 ~ FALSE,
        type=='p_different' & lwr>0 ~ TRUE,
        lwr<0 & scenario%in%c('s1', 's2') ~ FALSE,
        upr>0 & scenario%in%c('s3', 's4') ~ FALSE,
        T ~ TRUE ),
      type=ifelse(type=='p_different', 'P(Different)', 'P(A|Different)'),
      scenario = case_when(
        scenario=='s1'~ 'gain-gain VS gain',
        scenario=='s2'~ 'loss-loss VS loss',
        scenario=='s3'~ 'gain-loss VS gain',
        scenario=='s4'~ 'loss-gain VS loss'
      )) %>% 
    group_by(N, type, scenario) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>% 
    ggplot(aes(N, power, color=type)) +
    geom_line(size=1) +
    geom_point(size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    mytheme() + theme(legend.position = 'none') +
    facet_wrap(~scenario) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β', title = 'Original Paper Effect Size/4') +
    scale_color_jcolors(palette = "pal6")

pw4 <- power4 %>% 
    mutate(
      is_significant = case_when(
        type=='p_different' & lwr<0 ~ FALSE,
        type=='p_different' & lwr>0 ~ TRUE,
        lwr<0 & scenario%in%c('s1', 's2') ~ FALSE,
        upr>0 & scenario%in%c('s3', 's4') ~ FALSE,
        T ~ TRUE ),
      type=ifelse(type=='p_different', 'P(Different)', 'P(A|Different)'),
      scenario = case_when(
        scenario=='s1'~ 'gain-gain VS gain',
        scenario=='s2'~ 'loss-loss VS loss',
        scenario=='s3'~ 'gain-loss VS gain',
        scenario=='s4'~ 'loss-gain VS loss'
      )) %>% 
    group_by(N, type, scenario) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>% 
    ggplot(aes(N, power, color=type)) +
    geom_line(size=1) +
    geom_point(size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    mytheme() + theme(legend.position = 'none') +
    facet_wrap(~scenario) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β', title = 'Original Paper Effect Size/8') +
    scale_color_jcolors(palette = "pal6")

plot_grid(pw1, pw2, pw3, pw4, nrow=4, rel_heights = c(1.2, 1, 1, 1))

```


### {-}

<br><br>

## The sold-out ticket

<br>

### {.tabset}

#### Data

```{r plot-empirical-data-S2, message=F, warning=F, fig.width=8, fig.height=6, fig.align='center'}
# --------- Coding legend: --------- #
# -- Dependent Variable -- #
# response: 0
#           5 
#           10 
#           Other
# -- Explanatory Variables -- #
# cost: 0, 5, 10 (defined as p in Thaler 1985) 
#      [cost influence the "fair price" (p_star), which is operationalized
#       with the price asked to a friend]
# market_value : 5, 10
# buyer: friend (proxy for a fair price), stranger


# Create dataframe scenario 2
df <- data_short_MA %>% 
  select(contains('B', ignore.case =  F))

col_names <- names(df)
cost <- rep(c(0, 5, 10), each=2)
market_value <- rep(c(5, 10), 3)
col_idx <- seq(1,ncol(df),2)
df1 <- map_df(seq_along(col_idx), function(i){
  
  data.frame( response = c(df[,col_names[col_idx[i]]], df[,col_names[col_idx[i]+1]]),
              cost = cost[i],
              market_value = market_value[i],
              buyer = c(rep('Friend', n_sbj), rep('Stranger', n_sbj)) )
  
}) 

data_s2 <- df1 %>% 
  mutate(response=ifelse(response%in%unique(cost), response, 'Other'),
         response = factor(response, levels = c('0', '5', '10', 'Other')))

data_s2%>% 
  group_by(cost, market_value, buyer) %>% 
  count(response, .drop = F) %>% 
  ggplot(aes(response, n, fill=buyer)) +
  geom_bar(stat="identity", position=position_dodge(), color="black") + 
  mytheme() + 
  scale_fill_jcolors(palette = 'pal6') +
  labs(y=NULL, x=NULL) +
  facet_grid(cost~market_value)
```

#### Stan Code
```{stan stan-code-S2, output.var='multinomial_scenario_2', code=readLines('multinomial_scenario_2.stan'), cache = TRUE}
 
```

```{r print-stan-code-S2, eval = TRUE, echo = FALSE}
cat(get_stancode(multinomial_scenario_2))
```

#### Fit

```{r fit-stan-model-S2, message=F, warning=F, fig.width=6, fig.height=5, fig.align='center'}
# Create Stan Data
data_s2 <- data_s2 %>% 
  mutate(response=as.numeric(response),
         cost=as.factor(cost),
         market_value=as.factor(market_value))

X <- model.matrix(~ 0 + cost * market_value * buyer, data_s2)


#Stan Data
stan_data <- list(
  N       = nrow(data_s2),
  ncat    = max(data_s2$response),
  Y       = data_s2$response,
  X_5     = X,
  X_10    = X,
  X_Other = X,
  K_5     = ncol(X),
  K_10    = ncol(X),
  K_Other = ncol(X),
  
  prior_only = 0
)

psoftmax <- function(b) exp(c(0, b)) / sum(exp( c(0, b) ))

# Fit the model
fit_S2 <- rstan::sampling(multinomial_scenario_2, 
                          iter = 2000, 
                          cores = 4, 
                          data = stan_data, 
                          save_warmup = FALSE) 

```

**Plot Model Posteriors**

```{r plot-posteriors-stan-model-S2, message=F, warning=F, fig.width=8, fig.height=6, fig.align='center'}
extr_fit <- extract(fit_S2) 

make_designmatrix <- function(cost, market_value, buyer){
  if(cost=='0'){
    cost = c(1, 0, 0)
  } else if( cost=='5' ){
    cost = c(0, 1, 0)
  } else if( cost=='10' ){
    cost = c(0, 0, 1)
  }

  market_value10 <- ifelse( market_value=='10', 1, 0 )
  buyerStranger  <- ifelse( buyer=='Stranger', 1, 0 )


  x <- c(
    cost[1],
    cost[2],
    cost[3],
    market_value10,
    buyerStranger,
    cost[2]*market_value10,
    cost[3]*market_value10,
    cost[2]*buyerStranger,
    cost[3]*buyerStranger,
    market_value10*buyerStranger,
    cost[2]*market_value10*buyerStranger,
    cost[3]*market_value10*buyerStranger
  )
  return(x)
}


cost_i = '0'
market_value_i = '5'
buyer_i = 'Friend'

extracted_posterior <- map_dfr(c('0', '5', '10'), function(cost_i){
  # cat( '\n\n\nExtracting Posterior for')
  # cat(     '\n     - Cost:         ', cost_i)
  map_dfr(c('5', '10'), function(market_value_i){
    # cat(     '\n     - Market Value: ', market_value_i)
    map_dfr(c('Friend', 'Stranger'), function(buyer_i){
      # cat(     '\n     - Buyer:        ', buyer_i)

      b <- matrix(nrow = 4000, ncol = 3)
      # For each response (5, 10, Other)
      for( i in 1:3 ){
        b[,i] <- extr_fit[[i]]%*% make_designmatrix(cost=cost_i, market_value=market_value_i, buyer=buyer_i)
      }

      # For each sample
      map_dfr(1:4000, function(j){
        data.frame(post=psoftmax(b[j,]),
                   response=c('0', '5', '10', 'Other'),
                   cost = cost_i,
                   market_value = market_value_i,
                   buyer = buyer_i)
      })

    })
  })
})


extracted_posterior %>% 
  mutate(market_value = factor(market_value, levels = c('5', '10')),
         cost = factor(cost, levels = c('0','5', '10')),
         response = factor(response, levels = c('0', '5', '10', 'Other'))) %>% 
  # filter(buyer=='Friend', market_value=='5', cost=='0') %>% 
  ggplot(aes(x = response, y = post, fill=buyer, color=buyer)) + 
  stat_gradientinterval()+
  geom_line( data = extracted_posterior %>% 
               group_by(cost, market_value, buyer, response) %>% 
               summarise(mean_post=mean(post)) %>% 
                mutate(market_value = factor(market_value, levels = c('5', '10')),
                       cost = factor(cost, levels = c('0','5', '10')),
                       response = factor(response, levels = c('0', '5', '10', 'Other'))),
             aes(response, mean_post, group=buyer)) +
  mytheme() + scale_y_continuous(limits = 0:1) +
  labs(y = NULL, x = "Response Probability", color=NULL, fill=NULL) +
  scale_fill_jcolors(palette = "pal6") +
  scale_color_jcolors(palette = "pal6") +
  facet_grid(cost~market_value) +
  theme(legend.position = 'right')
```

### {-}

<br><br>

## Beer on the beach

<br>

### {.tabset}

#### Data

```{r plot-empirical-data-S3, message=F, warning=F, fig.width=6, fig.height=3.6, fig.align='center'}
# --------- Coding legend: --------- #
  # -- Dependent Variable -- #
  # response 
  # -- Explanatory Variables -- #
  # store: Resort hotel vs Grocery store
  
  # Create dataframe scenario 3
  data_s3 <- data_short_MA %>% 
    select(subject, contains('C', ignore.case = FALSE)) %>% 
    melt(id.var='subject',
         variable.name='store',
         value.name='response') %>% 
    mutate(store=ifelse(store=='C1_1', 'Resort Hotel', 'Grocery Store'),
           response=as.numeric(response))
  
  data_s3 %>% 
    ggplot(aes(response, fill=store, color=store)) +
    geom_density(alpha=.4, adjust=1.5) + 
    mytheme() + 
    theme(legend.position = c(0.7, 0.8)) +
    scale_fill_jcolors(palette = 'pal8') +
    scale_color_jcolors(palette = 'pal8') +
    # scale_y_continuous(labels=scales::percent, guide = "prism_offset") +
    scale_x_continuous(breaks = seq(0, 40, 10), limits = c(0, 40) ) +
    labs(y=NULL, x=NULL) 
```

#### Stan Code
```{stan stan-code-S3, output.var='gamma_scenario_3', code=readLines('gamma_scenario_3.stan'), cache = TRUE}

```

```{r print-stan-code-S3, eval = TRUE, echo = FALSE}
cat(get_stancode(gamma_scenario_3)) 
```

#### Fit

```{r fit-stan-model-S3, message=F, warning=F, fig.width=5, fig.height=3.5, fig.align='center'}
# Create Stan Data
X <- model.matrix(~ store, data_s3)

#Stan Data
stan_data <- list(
  N = nrow(data_s3),
  Y = data_s3$response,
  X = X,
  K = ncol(X),
  
  N_sbj    = n_sbj,
  J_sbj    = data_s3$subject,
  
  prior_only = 0
)

# Fit the model
fit_S3 <- rstan::sampling(gamma_scenario_3, 
                          iter = 2000, 
                          cores = 4, 
                          data = stan_data, 
                          save_warmup = FALSE)
```

**Plot Model Posteriors**

```{r plot-posteriors-stan-model-S3, message=F, warning=F, fig.width=4.5, fig.height=3.5, fig.align='center'}
draws <- extract(fit_S3)

draws$b %>%
  melt(value.name = 'post') %>%
  mutate(Var2=ifelse(Var2==1, 'Intercept', '')) %>%
  filter(Var2!='Intercept') %>%
  ggplot(aes(x = post, y = Var2)) +
  stat_halfeye(fill = jcolors::jcolors(palette = "pal8")[6],
               color = jcolors::jcolors(palette = "pal8")[12]) +
  mytheme() + geom_vline(xintercept = 0, linetype = 2) +
  labs(y = NULL, x = "Posterior Probability", title='Resort Hotel - Grocery Store') 
```

#### Power Analysis

```{r power-analysis-S3, message=F, warning=F, fig.width=6, results='hide', eval=TRUE}
# ---- Power Calculation ---- #
nModels <- 5
nChains <- 2
nClusters <- nModels*nChains

n_sim <- 100
n_sbj_range <- c(10, 50, 100, 150, 200, 250, 300) 

# Effect found in the paper Thaler 1985
# n_sbj_paper    = 87
store   = c('Resort Hotel', 'Grocery Store')
resort  = 2.65
grocery = 1.5

eff_size = resort - grocery

sim_y <- function(sbj, eff_size){
  
  resort  = 2.65
  linear_effect <- c( log(resort), log(resort-eff_size) )
  
  # Calculate the probability of responding 'different'
  inv_link = function(linear_predictor, shape) shape*exp(-linear_predictor)   

  store   = c('Resort Hotel', 'Grocery Store')
  
  std = 0.5
  
  # Random Effect
  re <- rnorm(1, 0, std)
  # Population Effect
  shape_gamma <- 25
  rate_gamma  <- inv_link(linear_effect, shape_gamma) 
  rate_gamma  <- rate_gamma + re
  
  data.frame(subject=sbj, store, response = rgamma(2, shape_gamma, rate_gamma))
}

# -- Run Models in Parallel -- #
samplingfunction<-function(x){ 
    
  store   = c('Resort Hotel', 'Grocery Store')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size)

  ## Create Stan Data
  X <- model.matrix(~ store, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(gamma_scenario_3,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(store[1], ' - ', store[2]),
      N        = n
    )
  # }
      
}

samplingfunction2<-function(x){ 
    
  store   = c('Resort Hotel', 'Grocery Store')

  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/2)

  ## Create Stan Data
  X <- model.matrix(~ store, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(gamma_scenario_3,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  
  efit <- rstan::extract(fit)
  
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(store[1], ' - ', store[2]),
      N        = n
    )
  # }
      
}

samplingfunction3<-function(x){ 
    
  store   = c('Resort Hotel', 'Grocery Store')

  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/4)
  
  ## Create Stan Data
  X <- model.matrix(~ store, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(gamma_scenario_3,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  
  efit <- rstan::extract(fit)
  
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(store[1], ' - ', store[2]),
      N        = n
    )
  # }
      
}

samplingfunction4<-function(x){ 
    
  store   = c('Resort Hotel', 'Grocery Store')

  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/8)

  ## Create Stan Data
  X <- model.matrix(~ store, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(gamma_scenario_3,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  
  efit <- rstan::extract(fit)
  
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(store[1], ' - ', store[2]),
      N        = n
    )
  # }
      
}

```

```{r power-analysis-computation-effsize1-S3, message=F, warning=F, results='hide', eval=TRUE}
power <- data.frame()   
for (n in n_sbj_range) {
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("gamma_scenario_3", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction)
    })
    power <- rbind(power, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
} 
```

```{r power-analysis-computation-effsize2-S3, message=F, warning=F, results='hide', eval=TRUE}
power2 <- data.frame()  
for (n in n_sbj_range) {
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("gamma_scenario_3", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction2)
    })
    power2 <- rbind(power2, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
} 
```

```{r power-analysis-computation-effsize3-S3, message=F, warning=F, results='hide', eval=TRUE}
power3 <- data.frame() 
for (n in n_sbj_range) { 
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("gamma_scenario_3", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction3)
    })
    power3 <- rbind(power3, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
} 
```

```{r power-analysis-computation-effsize4-S3, message=F, warning=F, results='hide', eval=TRUE}
power4 <- data.frame() 
for (n in n_sbj_range) { 
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("gamma_scenario_3", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction4)
    })
    power4 <- rbind(power4, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
} 
```

```{r plot-power-S3, message=F, warning=F, fig.width=7, fig.height=10, fig.align='center', eval=TRUE}
 
power_line_plot <- rbind(   
  power  %>% mutate(effsize = "Paper Effect Size"),
  power2 %>% mutate(effsize = "Paper Effect Size/2"),
  power3 %>% mutate(effsize = "Paper Effect Size/4"), 
  power4 %>% mutate(effsize = "Paper Effect Size/8")
  ) %>% 
  mutate(effsize = factor(effsize, levels = effect_size)) %>% 
    mutate( is_significant = ifelse(lwr>0, TRUE, FALSE) ) %>% 
    group_by(N, effsize) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>%  
    ggplot(aes(N, power)) +
    geom_line(aes(linetype=effsize, color=effsize), size=1) +
    geom_point(aes(color=effsize), size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β') +
    scale_color_jcolors(palette = "pal6") +
    mytheme() + theme(legend.position=c(0.8, 0.3))

power_quantile_plot <- rbind(
  power  %>% mutate(effsize = "Paper Effect Size"),
  power2 %>% mutate(effsize = "Paper Effect Size/2"),
  power3 %>% mutate(effsize = "Paper Effect Size/4"),
  power4 %>% mutate(effsize = "Paper Effect Size/8")
  ) %>%
    ggplot(aes(N, lwr, color = effsize)) +
    stat_pointinterval() +
    mytheme() + theme(legend.position = 'none') +
    geom_hline(yintercept = 0, linetype=2) +
    geom_line(data = rbind( power  %>% mutate(effsize = "Paper Effect Size"),
                            power2 %>% mutate(effsize = "Paper Effect Size/2"),
                            power3 %>% mutate(effsize = "Paper Effect Size/4"),
                            power4 %>% mutate(effsize = "Paper Effect Size/8")) %>% 
                group_by(N, effsize) %>% summarise(m=median(lwr)),
              aes(N, m, color=effsize)) +
    scale_x_continuous(breaks = NULL) +
    labs(x='Sample Size', y='2.5% Quantile Posterior') +
    scale_color_jcolors(palette = "pal6") +
    # scale_color_manual(values = c("gray80", "#6B244C")) +
  facet_wrap(~effsize)


plot_grid(plot_grid(NULL, power_line_plot, NULL, rel_widths = c(0.2, 1, 0.2), nrow = 1), 
          NULL,
          power_quantile_plot, 
          rel_heights = c(0.6, 0.1, 1),
          nrow = 3 )
```


### {-}

<br><br>

## Jacket-Calculator

<br>

### {.tabset}

#### Data

```{r plot-empirical-data-S4, message=F, warning=F, fig.width=3, fig.height=4, fig.align='center'}
# --------- Coding legend: --------- #
  # -- Dependent Variable -- #
  # response 
  # -- Explanatory Variables -- #
  # store: Resort hotel vs Grocery store
  
  # Create dataframe scenario 3
  data_s4 <- data_short_MA %>% 
    select(subject, contains('D', ignore.case = FALSE)) %>% 
    rename(low_price2 = D3, low_price1 = D2_1,
           high_price2 = D4, high_price1 = D2_2) %>% 
    melt(id.var='subject',
         variable.name='price',
         value.name='response') %>% 
    mutate(price=ifelse(str_detect(price, 'low'), 'low', 'high'),
           response=ifelse(response=='No', 0, 1))
  
  data_s4 %>% 
    filter(response==1) %>% 
    group_by(price) %>%
    count(response, .drop = F) %>% 
    ungroup() %>% 
    ggplot(aes(price, n, fill=price)) +
    geom_bar(stat = "identity", 
             # aes(y = (..count..)/sum(..count..)),
             position = position_dodge()) +
    mytheme() + theme(legend.position = 'none') +
    scale_fill_jcolors(palette = 'pal8') +
    scale_color_jcolors(palette = 'pal8') +
    # scale_y_continuous(labels=scales::percent, guide = "prism_offset") +
    labs(y='Number of "Yes"', x='Price') 
```

#### Stan Code
```{r stan-code-S4, cache=TRUE}
 bernoulli_scenario_4 <- rstan::stan_model('bernoulli_scenario_4.stan')
```

```{r print-stan-code-S4, eval = TRUE, echo = FALSE}
cat(get_stancode(bernoulli_scenario_4)) 
``` 

#### Fit

```{r fit-stan-model-S4, message=F, warning=F, fig.width=6, fig.height=5, fig.align='center'}
# Create Stan Data
X <- model.matrix(~ price, data_s4)

#Stan Data
stan_data <- list(
  N = nrow(data_s4),
  Y = data_s4$response,
  X = X,
  K = ncol(X),
  
  N_sbj    = n_sbj,
  J_sbj    = data_s4$subject,
  
  prior_only = 0
)

# Fit the model
fit_S4 <- rstan::sampling(bernoulli_scenario_4, 
                          iter = 2000, 
                          cores = 4, 
                          save_warmup = FALSE,
                          data = stan_data, 
                          save_warmup = FALSE)

```

**Plot Model Posteriors**

```{r plot-posteriors-stan-model-S4, message=F, warning=F, fig.width=4.5, fig.height=3.5, fig.align='center'}
extract(fit_S4)$b %>%
  melt(value.name = 'post') %>% 
  mutate(Var2=ifelse(Var2==1, 'Intercept', '')) %>% 
  filter(Var2!='Intercept') %>%
  ggplot(aes(x = post, y = Var2)) +  
  stat_halfeye(fill = jcolors::jcolors(palette = "pal8")[6], 
               color = jcolors::jcolors(palette = "pal8")[12]) + 
  mytheme() + geom_vline(xintercept = 0, linetype = 2) + 
  labs(y = NULL, x = "Posterior Probability", title='Low - High')

```

#### Power Analysis

```{r power-analysis-functions-S4, message=F, warning=F, results='hide', eval=TRUE} 
# ---- Power Calculation ---- #
nModels <- 5
nChains <- 2
nClusters <- nModels*nChains

n_sim <- 100
n_sbj_range <- c(10, 50, 100, 150, 200, 250, 300) 

# Effect found in the paper Thaler 1985
logit    = function(p) log(p/(1-p)) 
p_effect = c(0.29, 0.68)
linear_effect <- logit( p_effect )
eff_size = p_effect[2] - p_effect[1]
eff_size = linear_effect[2] - linear_effect[1]

sim_y <- function(sbj, eff_size){
  
  logit = function(p) log(p/(1-p)) 
  
  p_effect    = c(0.29, 0.68)
  price   = c('High', 'Low')
  linear_effect <- logit( p_effect )
  linear_effect[2]  <- linear_effect[1]+eff_size
  std = 0.5
  
  # Random Effect
  re <- rnorm(1, 0, std)
  # Population Effect
  theta  <- plogis(linear_effect+re)
  response = rbinom(2, 1, theta)

  data.frame(subject=sbj, price, response)
  
}

# -- Run Models in Parallel -- #
samplingfunction<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  
  efit <- rstan::extract(fit)
 
  data.frame(
    estimate = apply(efit$b, 2, mean)[2],
    lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
    upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
    store    = paste0(price[1], ' - ', price[2]),
    N        = n
    # Rhat_ok  = all(base::summary(fit)[['summary']][,'Rhat']<1.05)
  )
      
}

samplingfunction2<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/2)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(price[1], ' - ', price[2]),
      N        = n
    )
  # }
      
}

samplingfunction3<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/4)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(price[1], ' - ', price[2]),
      N        = n
    )
  # }
      
}
 
samplingfunction4<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/8)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(price[1], ' - ', price[2]),
      N        = n
    )
  # }
      
}
```

```{r power-analysis-computation-effsize1-S4, message=F, warning=F, results='hide', eval=TRUE}
power <- data.frame()    
for (n in n_sbj_range) { 
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("bernoulli_scenario_4", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction)
    })
    power <- rbind(power, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
}   
```

```{r power-analysis-computation-effsize2-S4, message=F, warning=F, results='hide', eval=TRUE}
power2 <- data.frame()    
for (n in n_sbj_range) {
    message("\n\nN Subjects: ", n) 

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("bernoulli_scenario_4", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction2)
    })
    power2 <- rbind(power2, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
}  
```

```{r power-analysis-computation-effsize3-S4, message=F, warning=F, results='hide', eval=TRUE}
power3 <- data.frame()    
for (n in n_sbj_range) {
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("bernoulli_scenario_4", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction3)
    })
    power3 <- rbind(power3, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
}  
```

```{r power-analysis-computation-effsize4-S4, message=F, warning=F, results='hide', eval=TRUE}
power4 <- data.frame()    
for (n in n_sbj_range) {
    message("\n\nN Subjects: ", n, "\n")

    message("Setting up Clusters...")
    cl <- parallel::makeCluster(nClusters, outfile = "")
    parallel::clusterExport(cl, c("bernoulli_scenario_4", "n_sbj_range", "sim_y", 
                                  "eff_size", "n"))

    out <- map_dfr(seq_len(round(n_sim/nModels)), function(i) {
        message("\r", "Simulation: ", i * nModels, "/", n_sim, appendLF = FALSE)
        parallel::parLapply(cl, 1:nModels, samplingfunction4)
    })
    power4 <- rbind(power4, out)

    message("Shutting down Clusters...")
    parallel::stopCluster(cl)
}  
```


```{r plot-power-S4, message=F, warning=F, fig.width=7, fig.height=10, fig.align='center', eval=TRUE}
power_line_plot <- rbind(   
  power  %>% mutate(effsize = "Paper Effect Size"),
  power2 %>% mutate(effsize = "Paper Effect Size/2"),
  power3 %>% mutate(effsize = "Paper Effect Size/4"), 
  power4 %>% mutate(effsize = "Paper Effect Size/8")
  ) %>% 
  mutate(effsize = factor(effsize, levels = effect_size)) %>% 
    mutate( is_significant = ifelse(lwr>0, TRUE, FALSE) ) %>% 
    group_by(N, effsize) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>%  
    ggplot(aes(N, power)) +
    geom_line(aes(linetype=effsize, color=effsize), size=1) +
    geom_point(aes(color=effsize), size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β') +
    scale_color_jcolors(palette = "pal6") +
    mytheme() + theme(legend.position='right')

power_quantile_plot <- rbind(
  power  %>% mutate(effsize = "Paper Effect Size"),
  power2 %>% mutate(effsize = "Paper Effect Size/2"),
  power3 %>% mutate(effsize = "Paper Effect Size/4"),
  power4 %>% mutate(effsize = "Paper Effect Size/8")
  ) %>%
    ggplot(aes(N, lwr, color = effsize)) +
    stat_pointinterval() +
    mytheme() + theme(legend.position = 'none') +
    geom_hline(yintercept = 0, linetype=2) +
    geom_line(data = rbind( power  %>% mutate(effsize = "Paper Effect Size"),
                            power2 %>% mutate(effsize = "Paper Effect Size/2"),
                            power3 %>% mutate(effsize = "Paper Effect Size/4"),
                            power4 %>% mutate(effsize = "Paper Effect Size/8")) %>% 
                group_by(N, effsize) %>% summarise(m=median(lwr)),
              aes(N, m, color=effsize)) +
    scale_x_continuous(breaks = NULL) +
    labs(x='Sample Size', y='2.5% Quantile Posterior') +
    scale_color_jcolors(palette = "pal6") +
    # scale_color_manual(values = c("gray80", "#6B244C")) +
  facet_wrap(~effsize)


plot_grid(plot_grid(power_line_plot, rel_widths = c(0.2, 1, 0.2), nrow = 1), 
          NULL,
          power_quantile_plot, 
          rel_heights = c(0.6, 0.1, 1),
          nrow = 3 )

```


### {-}

## Lost Ticket

<br>

### {.tabset}

#### Data

```{r plot-empirical-data-S5, message=F, warning=F, fig.width=3, fig.height=4, fig.align='center'}
# --------- Coding legend: --------- #
# -- Dependent Variable -- #
# response 
# -- Explanatory Variables -- #
# loss: ticket vs cash

# Create dataframe scenario 3
data_s5 <- data_short_MA %>% 
  select(subject, contains('E', ignore.case = FALSE)) %>%
  rename(ticket = E1, 
         cash = E2) %>% 
  melt(id.var='subject',
       variable.name='loss',
       value.name='response') %>% 
  mutate(response=ifelse(response=='No', 0, 1))

data_s5 %>% 
  filter(response==1) %>% 
  group_by(loss) %>%
  count(response, .drop = F) %>% 
  ungroup() %>% 
  ggplot(aes(loss, n, fill=loss)) +
  geom_bar(stat = "identity", 
           # aes(y = (..count..)/sum(..count..)),
           position = position_dodge()) +
  mytheme() + theme(legend.position = 'none') +
  scale_fill_jcolors(palette = 'pal8') +
  scale_color_jcolors(palette = 'pal8') +
  # scale_y_continuous(labels=scales::percent, guide = "prism_offset") +
  labs(y='Number of "Yes"', x='Loss') 
```

#### Stan Code

```{r print-stan-code-S5, eval = TRUE, echo = FALSE}
cat(get_stancode(bernoulli_scenario_4)) 
```

#### Fit

```{r fit-stan-model-S5, message=F, warning=F, fig.width=6, fig.height=5, fig.align='center'}
# Create Stan Data
X <- model.matrix(~ loss, data_s5)

#Stan Data
stan_data <- list(
  N = nrow(data_s5),
  Y = data_s5$response,
  X = X,
  K = ncol(X),
  
  N_sbj    = n_sbj,
  J_sbj    = data_s3$subject,
  
  prior_only = 0
)

# Fit the model
fit_S5 <- rstan::sampling(bernoulli_scenario_4, 
                          iter = 2000, 
                          cores = 4, 
                          save_warmup = FALSE,
                          data = stan_data, 
                          save_warmup = FALSE)
```

**Plot Model Posteriors**

```{r plot-posteriors-stan-model-S5, message=F, warning=F, fig.width=4.5, fig.height=3.5, fig.align='center'}
extract(fit_S5)$b %>%
    melt(value.name = 'post') %>% 
    mutate(Var2=ifelse(Var2==1, 'Intercept', '')) %>% 
    filter(Var2!='Intercept') %>%
    ggplot(aes(x = post, y = Var2)) + 
    stat_halfeye(fill = jcolors::jcolors(palette = "pal8")[6], 
                 color = jcolors::jcolors(palette = "pal8")[12]) + 
    mytheme() + geom_vline(xintercept = 0, linetype = 2) + 
    labs(y = NULL, x = "Posterior Probability", title='Ticket - Cash') 

```

#### Power Analysis

```{r power-analysis-functions-S5, message=F, warning=F, results='hide', eval=FALSE}

# ---- Power Calculation ---- #
nModels <- 5
nChains <- 2
nClusters <- nModels*nChains

n_sim <- 100
n_sbj_range <- c(10, 50, 100, 150, 200, 250, 300) 

# Effect found in the paper Thaler 1985
logit    = function(p) log(p/(1-p)) 
loss       = c('Cash', 'Ticket')
p_effect    = c(0.88, 0.46)

linear_effect <- logit( p_effect )
eff_size = linear_effect[2] - linear_effect[1]

sim_y <- function(sbj, eff_size){
  
  logit = function(p) log(p/(1-p)) 
  
  loss       = c('Cash', 'Ticket')
  p_effect    = c(0.88, 0.46)
  linear_effect <- logit( p_effect )
  linear_effect[2]  <- linear_effect[1]-eff_size
  std = 0.5
  
  # Random Effect
  re <- rnorm(1, 0, std)
  # Population Effect
  theta  <- plogis(linear_effect+re)
  response = rbinom(2, 1, theta)

  data.frame(subject=sbj, price, response)
  
}

# -- Run Models in Parallel -- #
samplingfunction<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  
  efit <- rstan::extract(fit)
 
  data.frame(
    estimate = apply(efit$b, 2, mean)[2],
    lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
    upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
    store    = paste0(price[1], ' - ', price[2]),
    N        = n
    # Rhat_ok  = all(base::summary(fit)[['summary']][,'Rhat']<1.05)
  )
      
}

samplingfunction2<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/2)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(price[1], ' - ', price[2]),
      N        = n
    )
  # }
      
}

samplingfunction3<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/4)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(price[1], ' - ', price[2]),
      N        = n
    )
  # }
      
}
 
samplingfunction4<-function(x){ 
    
  price   = c('Low', 'High')
  #Simulate data
  data_sim <- purrr::map_dfr(seq_len(n), sim_y, eff_size=eff_size/8)

  ## Create Stan Data
  
  X <- model.matrix(~ price, data_sim)

  #Stan Data
  stan_data <- list(
    N = nrow(data_sim),
    Y = data_sim$response,
    X = X,
    K = ncol(X),
    
    N_sbj    = n,
    J_sbj    = data_sim$subject,
    
    prior_only = 0
  )

  fit <- rstan::sampling(bernoulli_scenario_4,
                         iter    = 2000,
                         chains  = 2,
                         cores   = 2,
                         pars    = 'b',
                         refresh = 0,
                         data    = stan_data,
                         save_warmup = FALSE
                         )
  # s <- summary(fit)
  # if( all(s$summary[,'Rhat']<1.05) ){
    efit <- rstan::extract(fit)
   
    data.frame(
      estimate = apply(efit$b, 2, mean)[2],
      lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
      upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
      store    = paste0(price[1], ' - ', price[2]),
      N        = n
    )
  # }
      
}


# ---- Functions Power Calculation ---- #
# Calculate the probability of responding 'different'

logit = function(p) log(p/(1-p)) 

# Effect found in the paper Tversky, Kahneman, 1981
n_sbj_paper = 90
loss       = c('Cash', 'Ticket')
p_effect    = c(0.88, 0.46)

linear_effect <- c( logit(p_effect) )
assumed_sd = 0.5

sim_y <- function(sbj, linear_effect, std){
  # Random Effect
  re <- rnorm(1, 0, std)
  # Population Effect
  theta  <- plogis(linear_effect+re)
  response = rbinom(2, 1, theta)

  data.frame(subject=sbj, loss, response)
}

linear_effect1 <-  linear_effect
linear_effect2 <-  linear_effect/2
linear_effect3 <-  linear_effect/4
linear_effect4 <-  linear_effect/8

# -- Run Models in Parallel -- #
samplingfunction<-function(i, n_sbj, linear_effect, std){ 
    #Simulate data
    data_sim <- map_dfr(seq_len(n_sbj), sim_y, linear_effect, std)
  
    ## Create Stan Data
    X <- model.matrix(~ loss, data_sim)
  
    #Stan Data
    stan_data <- list(
      N = nrow(data_sim),
      Y = data_sim$response,
      X = X,
      K = ncol(X),
      
      N_sbj    = n_sbj,
      J_sbj    = data_sim$subject,
      
      prior_only = 0
    )
  
    # Fit the model
    fit <- rstan::sampling(bernoulli_scenario_4, 
                           iter = 2000, 
                           cores = 2, 
                           chains = 2,
                           refresh = 0,
                           data = stan_data, 
                           save_warmup = FALSE)
}

nParModels <- 4; nChains <- 2
nClasters <- nParModels*nChains
cl <- parallel::makeCluster(nClasters, outfile = "")
parallel::clusterExport(cl, c('bernoulli_scenario_4', 'loss',
                              'stan_data', 'samplingfunction', 'map_dfr', 'sim_y', 
                              'linear_effect1', 'linear_effect2', 'linear_effect3', 'linear_effect4',
                              'assumed_sd'))

get_estimate <- function(n_sbj, linear_effect, std){
  
  # - Fit Model - #
  out <- parallel::parLapply(cl, 1:nParModels, samplingfunction, 
                             n_sbj=n_sbj, std=std, linear_effect=linear_effect)
  
  map_dfr( 1:nParModels, function(i){
    
    s <- summary( out[[i]] )$summary
    rhat <- s[, 'Rhat']
    if( all(rhat<1.05) ){
      efit <- extract(out[[i]])
      data.frame(
        estimate = apply(efit$b, 2, mean)[2],
        lwr      = apply(efit$b, 2, quantile, probs=0.025)[2],
        upr      = apply(efit$b, 2, quantile, probs=0.975)[2],
        store    = paste0(loss[2], ' - ', loss[1]),
        effsize  = linear_effect[2]-linear_effect[1]
      )
    }
     
  })
}

```

```{r power-analysis-computation-effsize1-S5, message=F, warning=F, results='hide', eval=FALSE}
# ---- Power Calculation ---- #
power <- map_dfr(n_sbj_range, function(n_sbj) {
    message("\n\nN Subjects: ", n_sbj)
    map_dfr(1:actual_n_sim, function(i) {
        message("\r", "Simulation: ", i * 4, "/", n_sim, appendLF = FALSE)
        get_estimate(n_sbj = n_sbj, linear_effect1, assumed_sd)
    }) %>% mutate(simulation = 1:n_sim, N = n_sbj)
})
```

```{r power-analysis-computation-effsize2-S5, message=F, warning=F, results='hide', eval=FALSE}
# ---- Power Calculation ---- #
power2 <- map_dfr(n_sbj_range, function(n_sbj) {
    message("\n\nN Subjects: ", n_sbj)
    map_dfr(1:actual_n_sim, function(i) {
        message("\r", "Simulation: ", i * 4, "/", n_sim, appendLF = FALSE)
        get_estimate(n_sbj, linear_effect2, assumed_sd)
    }) %>% mutate(simulation = 1:n_sim, N = n_sbj)
})
```

```{r power-analysis-computation-effsize3-S5, message=F, warning=F, results='hide', eval=FALSE}
# ---- Power Calculation ---- #
power3 <- map_dfr(n_sbj_range, function(n_sbj) {
    message("\n\nN Subjects: ", n_sbj)
    map_dfr(1:actual_n_sim, function(i) {
        message("\r", "Simulation: ", i * 4, "/", n_sim, appendLF = FALSE)
        get_estimate(n_sbj, linear_effect3, assumed_sd)
    }) %>% mutate(simulation = 1:n_sim, N = n_sbj)
})
```

```{r power-analysis-computation-effsize4-S5, message=F, warning=F, results='hide', eval=FALSE}
# ---- Power Calculation ---- #
power4 <- map_dfr(n_sbj_range, function(n_sbj) {
    message("\n\nN Subjects: ", n_sbj)
    map_dfr(1:actual_n_sim, function(i) {
        message("\r", "Simulation: ", i * 4, "/", n_sim, appendLF = FALSE)
        get_estimate(n_sbj, linear_effect4, assumed_sd)
    }) %>% mutate(simulation = 1:n_sim, N = n_sbj)
})
```

```{r plot-power-S5, message=F, warning=F, fig.width=6, fig.height=6, fig.align='center', eval = FALSE}
power_line_plot <- rbind(
  power  %>% mutate(effsize = "Paper Effect Size"),
  power2 %>% mutate(effsize = "Paper Effect Size/2"),
  power3 %>% mutate(effsize = "Paper Effect Size/4"),
  power4 %>% mutate(effsize = "Paper Effect Size/10")
  ) %>% 
  mutate(effsize = factor(effsize, levels = effect_size)) %>% 
    mutate( is_significant = ifelse(upr<0, TRUE, FALSE) ) %>% 
    group_by(N, effsize) %>% 
    summarise(power = mean(is_significant)) %>% 
    ungroup() %>% 
    ggplot(aes(N, power)) +
    geom_line(aes(linetype=effsize, color=effsize), size=1) +
    geom_point(aes(color=effsize), size=3) +
    geom_hline(yintercept=0.8, linetype=2) +
    scale_y_continuous(limits = c(0,1), labels=scales::percent) +
    scale_x_continuous(breaks = n_sbj_range) +
    labs(x='Sample Size', y='1-β') +
    scale_color_jcolors(palette = "pal6") +
    mytheme() + theme(legend.position=c(0.8, 0.5))

power_quantile_plot <- rbind(
  power  %>% mutate(effsize = "Paper Effect Size"),
  power2 %>% mutate(effsize = "Paper Effect Size/2"),
  power3 %>% mutate(effsize = "Paper Effect Size/4"),
  power4 %>% mutate(effsize = "Paper Effect Size/10")
  ) %>%
    ggplot(aes(N, upr, fill = stat(y > 0))) +
    stat_slab() +
    mytheme() + theme(legend.position = 'none') +
    geom_hline(yintercept = 0, linetype=2) +
    geom_line(data = rbind( power  %>% mutate(effsize = "Paper Effect Size"),
                            power2 %>% mutate(effsize = "Paper Effect Size/2"),
                            power3 %>% mutate(effsize = "Paper Effect Size/4"),
                            power4 %>% mutate(effsize = "Paper Effect Size/10")) %>% 
                group_by(N, effsize) %>% summarise(m=median(upr)),
              aes(N, m, linetype=effsize, color=effsize)) +
    scale_x_continuous(breaks = NULL) +
    labs(x='Sample Size', y='2.5% Quantile Posterior') +
    scale_color_jcolors(palette = "pal6") +
    scale_fill_manual(values = c("gray80", "#6B244C")) +
  facet_wrap(~effsize)


plot_grid(plot_grid(NULL, power_line_plot, NULL, rel_widths = c(0.2, 1, 0.2), nrow = 1), 
          NULL,
          power_quantile_plot, 
          rel_heights = c(0.6, 0.1, 1),
          nrow = 3 )

```

### {-}

